# Java 
## 字符
### UNICODE
基于世界级“书同文”需求推出的编码字符集,兼容ASCII字符集。
**UTF-8(Unicode Transformation Format):** **面向Unicode字符集**的**可变长**编码规范，==使用1至4Byte表示字符==。
**UTF-8 基于前缀判断字符长度**
```
    码点范围                于内存中
    U+0000~U+007F           0*** ****
    U+008F~U+07FF           110* ****   10** ****  
    U+08FF~U+FFFF           1110 ****   1110 ****    10** ****
    U+10000~U+10FFFF        1111 0***   10** ****    10** ****    10** ****   
```
&nbsp;
**UTF-16:** **Java默认编码规范！** 面向Unicode字符集**基于代理对**的扩展编码规范，==使用2或4Byte表示字符==。
**UTF-16 基于代理对扩展空间**
* 基于多语言平台(BMP): U+0000~U+FFFF -> 直接存储为2Byte
* 辅助平面字符: U+10000~U+10FFFF ->拆分为两个 **代理码元** （4Byte）
  
**UTF-16 Surrogate Pair(代理对)**: Unicode中 **辅助平面字符 (超出基本多语言平面(BMP)的字符，一般为表情、生僻字、专业符号等。范围为 U+10000~U+10FFFF)** 码点超过 0xFFFF，而UTF-16编码的`char`只能存储 16bit (2Byte)。此时便需要以4Byte表示字符。
```
    码点范围                于内存中
    U+0000~U+FFFF           0000 xxxx xxxx xxxx
    U+1000~U+10FFFF         HIGT_SURROGATE (1101 10xx xxxx xxxx)
                            LOW_SURROGATE  (1101 11xx xxxx xxxx)
```

---
### Stirng
#### '+'操作符拼接字符串原理
---
#### 字符串常量池(String Pool)与Immutable原理
---
#### 字符串的创建方式以及内存回收
---
#### StringBuider
---
#### StringBuffer
---
### Regex
--- 
## 大数计算
---
## 面向对象编程(Oriented Object Programming)

当软件工程的老师们介绍面向对象编程时，我们总会听到这样的说辞：“其实很简单！**面向对象编程的核心就是抽象！**”
Almighty God! 仅仅只是“抽象”一词，就已经足够“抽象”了！
学生们又怎么能够理解所谓——“面向对象和核心就是抽象”,这样绕口的话呢。

**下面我将为你解释“抽象”**
**“抽象”** 对应英语词汇 **"abstract"**，源于拉丁语:
  * **"abstractus"**
  其词根与词缀
    * **"abs-"**:表示“脱离”、“远离”
    * **"tract"**:表示“拖”、“拉”

意为 **“剥离具体的事物”**。这样看来似乎这一次想表达的意思就是“原理、逃离”，并且再做点什么比如说“拉”或者“抽”。
对于中文的 **“抽象”**，我倾向于解释其为 **“抽离具体的象（现象）”**，或者说 **“从具体中，‘抽’出概念（的象）”**。似乎就相当于上文说的先“脱离”，后“抽出”。
似乎这些话还是不太好理解，不过别担心，抽象实际上是人人都具备的天赋，因为我们所有的名词实际上都是通过“抽象”得到的，因此只要你会说话，你就可以理解“抽象”。
想想你的家人、朋友、同学，他们有什么共同特点？
他们有各种各样的特点：
这些人中有男有女，有年轻的有年迈的，有喜欢编程的也有对此不感兴趣的。
他们每个人独一无二，但在诸多不似之中，有唯一确定的相似之处：**他们都是“人”**。
计算机专业的我们，似乎不知道人在生物学或伦理学上的严格定义。
但我们都知道什么是 **“人”**，这是一种概念，**我们好像说不清人是什么，但我们总能知道什么是人。为什么？**
**因为当我们向他人解释“人”的概念时，难以办法提出一个具体的人作为解释。“人”作为一个概念。大家都属于人，而人不等于具体的某个人。这就是抽象！**
我们脱离了所有具体的人，你的父母或者你最好的朋友这样具体的客体，得到了一个 **非具体**的概念——“人”。
==**“抽象”——即从纷繁普遍的同类事物中总结出的共性。**==
**让我们看看其严格的解释，“抽象——从具体事物抽出、概括出它们共同的方面、本质属性与关系等，而将个别的、非本质的方面、属性与关系舍弃，这种思维过程，称为抽象。”**

**为什么需要程序设计需要“抽象”？**
我们之前说了，我们语言使用频率最高的词汇是动词与名词。而几乎所有的名词都是概念性的，它们都是通过抽象得到的。
当我们与他人沟通时，想要传递某个类别或者概念的信息，我们就自己必须先进行抽象，才能将这个信息传递给别人。
**"programming language are also language"——程序设计语言亦是语言**，而“抽象”能力作为一种思维能力，思维进而作为语言的基础。**“抽象”是我们能够更好地描述数据与过程的基础。**

---
### 访问权限控制(Access Control)
* **public** : 
  * 可见范围：全局可见
  * 访问权限：随意访问
  
* **default** :
  * 可见范围：包内可见
  * 访问权限：包内可访问

* **protected** :
  * 可见范围：包内可见
  * 访问权限：子类可访问
  
* **private** :
  * 可见范围：类内可见
  * 访问权限：类内可访问

### final
* final修饰变量：常量
* final修饰方法：禁止重写方法
* fianl修饰类：禁止继承

### static
**注意事项**：
* 静态方法只能访问静态成员
* 静态方法中不存在this

---
### Objact类
#### hashCode

### 继承(Inheritance)
**关于Java继承的特性：仅支持单继承，不支持多继承，但支持多重继承。**

#### 继承的实质
JVM中，每个类在内存中都有两种核心结构：
1. **Klass对象**： 存储类的元数据（类似“类模板”），由JVM在类加载时创建，全局唯一
2. **对象实例**： 存储具体对象的数据，包括字段值， 对象头。

##### Klass对象
Klass对象是JVM内部用于描述类的元数据结构，包含由以下**关键信息**:
* **类名、访问权限修饰符**：类的名称
* **父类指针**：指向父类的Klass对象
* **虚方法表(VMT)**：存储所有可重写方法的指针
* **非虚方法表**：存储*static*、*private*、*final*方法的指针
* **字段偏表**：记录每个字段在对象内存中的偏移量（用于快速访问字段）
* **接口表**：记录实现的接口及其方法表(itable)
  
#### 对象实例内存分布
对象实例在内存中分为三部分：
1. **对象头(Header)**:
   * **Mark Word**：存储哈希码、锁状态、GC分代年龄
   * **Klass Pointer**：指向该实例所属类的Klass对象
2. **实例数据(Instance Data)**：
   * 存储所有字段的值，按继承顺序排列
3. **对齐填充(Padding)**：
   * 确保对象总大小为8字节的倍数（内存对齐优化）

#### JVM实现继承
继承的底层实现分为两个阶段：**类加载、内存分配**。

##### 类加载阶段
JVM加载类时
1. **递归加载父类**：
   从Sub类向上递归加载Base->...->Object，确保所有父类已加载
2. **验证继承关系**：
   检验父类是否*final*，方法签名是否冲突（子类重写final方法时抛出*ClassFormatError*异常）
3. **构建Klass对象**：
   * 合并父类的字段合方法，生成子类独有元数据
   * 构建虚方法表：
     * 初始化为父类VMT副本
     * 遍历子类方法，若重写父类方法，则替换VMT中对应条目
     * 新增子类方法添加到VMT末尾
  
##### 内存分配
JVM创建子类对象时
1. **分配内存**：
2. **初始化对象头(Header)**：
   设置 *Klass Pointer*指向其Klass对象
3. **初始化字段**：

### 多态(Polymorphism)
多态的核心是**动态绑定**，即根据对象的实际类型，动态决定调用哪个方法。
* 多态的优势
  * 多态形式使用父类的引用指向子类对象，降低代码耦合度
  * 使用父类作为参数传递，提高比扩展性

#### 方法存储位置与Klass对象的关系
1. Klass对象中维护两个关键表：
   * **虚方法表(VMT)**：存储所有可重写方法的指针。
   * **非虚方法表**：存储*static*、*private*、*final*方法的指针。
2. 方法区(Mehtod Area)：
   * 方法区是JVM规范定义的内存区域，存储 类元数据、字节码、常量池等。
   * **方法的具体实现**存储在方区，而Klass对象的方法表金存储指向这些实现的指针。

#### 方法调用
不同类型的方法调用机制不同
1. **虚方法（动态绑定）**：
   * 调用 invokevitrual指令
   * **执行流程**：
     1. 通过对象头的Klass Pointer，访问其Klass对象
     2. 从Klass对象中获取VMT
     3. 根据方法索引（编译时确定）在VMT中查找对应方法
     4. 执行方法
2. **非虚方法（静态绑定）**：
   * **static方法**：
     * 调用 invokestatic指令
     * **定位方式**：
        直接通过类中的Klass对象中的**非虚方法表**找到方法地址
     * **底层原理**：
        静态方法属于类，与实例无关，JVM通过Klass对象直接定位到方法入口地址
   * **private/final方法**：
     * 调用 invokespecial指令
     *  **定位方式**：
        编译时直接通过绑定到具体方法地址（硬编码到字节码中），或通过Klass对象的**非虚方法表**索引找到地址
     * **底层原理**：
       private方法不可被继承，final方法不可被重写，因此它们的地址在类加载时即可确定。

#### 总结
子类会在内存中完成保存父类的结构，包括所有字段和方法，但**方法权限**决定了子类可见性。


## 数据解构与算法

### 数据结构

#### 线性结构
##### List
###### ArrayList(动态数组)
###### LinkedList(双向链表)

##### Queue&Deque
###### ArrayDeque(双端队列)
###### PriorityQueue(优先堆)

##### Stack

#### 非线性结构
##### Set
###### HashSet(哈希表)
###### LinkedHashSet(哈希链表)
###### TreeSet(红黑树)
##### Map
###### HashMap(哈希表)
###### LinkedHashMap(有序哈希)
###### TreeMap(红黑树)

### 算法
#### 函数式编程（Lambda）
#### 迭代器（Iterator）
#### 流式编程(Stream API)
#### 工具类与API
##### Arrays
##### sort
##### binarySearch

#### 排序算法
##### 快速排序
##### 归并排序
##### 堆排序
#### 查找算法

#### 递归算法
#### 动态规划
#### 贪心算法
##### dijkstra算法
#### 回溯算法
---
### IO
### 多线程
### 网络编程
### 反射
### 动态代理
---
# JavaScript
## 变量声明
---
## 数据类型
### 基础类型
### 引用类型
---
## 运算符
---
## 函数
#### 函数声明
#### 函数表达式
#### 箭头函数
#### 作用域与闭包
---
## OOP
### 对象创建
### 原型与继承
### 内置对象
#### Object
#### Number
#### String
#### Boolean
#### Symbol
#### Array
#### Map
#### Set
#### Math
#### Date
---
## DOM操作
### 节点操作
### 事件系统
### BOM
#### 定时器
#### location&history
### localStorage&sessionStorage
### cooke
### 网络请求
#### XMLHttpRequset
#### Fetch API