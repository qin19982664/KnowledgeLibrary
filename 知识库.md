# Java 
## 字符
### UNICODE
基于世界级“书同文”需求推出的编码字符集,兼容ASCII字符集。
**UTF-8(Unicode Transformation Format):** **面向Unicode字符集**的**可变长**编码规范，==使用1至4Byte表示字符==。
**UTF-8 基于前缀判断字符长度**
```
    码点范围                于内存中
    U+0000~U+007F           0*** ****
    U+008F~U+07FF           110* ****   10** ****  
    U+08FF~U+FFFF           1110 ****   1110 ****    10** ****
    U+10000~U+10FFFF        1111 0***   10** ****    10** ****    10** ****   
```
&nbsp;
**UTF-16:** **Java默认编码规范！** 面向Unicode字符集**基于代理对**的扩展编码规范，==使用2或4Byte表示字符==。
**UTF-16 基于代理对扩展空间**
* 基于多语言平台(BMP): U+0000~U+FFFF -> 直接存储为2Byte
* 辅助平面字符: U+10000~U+10FFFF ->拆分为两个 **代理码元** （4Byte）
  
**UTF-16 Surrogate Pair(代理对)**: Unicode中 **辅助平面字符 (超出基本多语言平面(BMP)的字符，一般为表情、生僻字、专业符号等。范围为 U+10000~U+10FFFF)** 码点超过 0xFFFF，而UTF-16编码的`char`只能存储 16bit (2Byte)。此时便需要以4Byte表示字符。
```
    码点范围                于内存中
    U+0000~U+FFFF           0000 xxxx xxxx xxxx
    U+1000~U+10FFFF         HIGT_SURROGATE (1101 10xx xxxx xxxx)
                            LOW_SURROGATE  (1101 11xx xxxx xxxx)
```

---
### Stirng
#### '+'操作符拼接字符串原理
---
#### 字符串常量池(String Pool)与Immutable原理
---
#### 字符串的创建方式以及内存回收
---
#### StringBuider
---
#### StringBuffer
---
### Regex
--- 
## 大数计算
---
## 面向对象编程(Oriented Object Programming)

当软件工程的老师们介绍面向对象编程时，我们总会听到这样的说辞：“其实很简单！**面向对象编程的核心就是抽象！**”
Almighty God! 仅仅只是“抽象”一词，就已经足够“抽象”了！
学生们又怎么能够理解所谓——“面向对象和核心就是抽象”,这样绕口的话呢。

**下面我将为你解释“抽象”**
**“抽象”** 对应英语词汇 **"abstract"**，源于拉丁语:
  * **"abstractus"**
  其词根与词缀
    * **"abs-"**:表示“脱离”、“远离”
    * **"tract"**:表示“拖”、“拉”

意为 **“剥离具体的事物”**。这样看来似乎这一次想表达的意思就是“原理、逃离”，并且再做点什么比如说“拉”或者“抽”。
对于中文的 **“抽象”**，我倾向于解释其为 **“抽离具体的象（现象）”**，或者说 **“从具体中，‘抽’出概念（的象）”**。似乎就相当于上文说的先“脱离”，后“抽出”。
似乎这些话还是不太好理解，不过别担心，抽象实际上是人人都具备的天赋，因为我们所有的名词实际上都是通过“抽象”得到的，因此只要你会说话，你就可以理解“抽象”。
想想你的家人、朋友、同学，他们有什么共同特点？
他们有各种各样的特点：
这些人中有男有女，有年轻的有年迈的，有喜欢编程的也有对此不感兴趣的。
他们每个人独一无二，但在诸多不似之中，有唯一确定的相似之处：**他们都是“人”**。
计算机专业的我们，似乎不知道人在生物学或伦理学上的严格定义。
但我们都知道什么是 **“人”**，这是一种概念，**我们好像说不清人是什么，但我们总能知道什么是人。为什么？**
**因为当我们向他人解释“人”的概念时，难以办法提出一个具体的人作为解释。“人”作为一个概念。大家都属于人，而人不等于具体的某个人。这就是抽象！**
我们脱离了所有具体的人，你的父母或者你最好的朋友这样具体的客体，得到了一个 **非具体**的概念——“人”。
==**“抽象”——即从纷繁普遍的同类事物中总结出的共性。**==
**让我们看看其严格的解释，“抽象——从具体事物抽出、概括出它们共同的方面、本质属性与关系等，而将个别的、非本质的方面、属性与关系舍弃，这种思维过程，称为抽象。”**

**为什么需要程序设计需要“抽象”？**
我们之前说了，我们语言使用频率最高的词汇是动词与名词。而几乎所有的名词都是概念性的，它们都是通过抽象得到的。
当我们与他人沟通时，想要传递某个类别或者概念的信息，我们就自己必须先进行抽象，才能将这个信息传递给别人。
**"programming language are also language"——程序设计语言亦是语言**，而“抽象”能力作为一种思维能力，思维进而作为语言的基础。**“抽象”是我们能够更好地描述数据与过程的基础。**

---

### Static
  **注意事项**：
  * 静态方法只能访问静态成员
  * 静态方法中不存在this

---
## 数据解构与算法

### 数据结构

#### 线性结构
##### List
###### ArrayList(动态数组)
###### LinkedList(双向链表)

##### Queue&Deque
###### ArrayDeque(双端队列)
###### PriorityQueue(优先堆)

##### Stack

#### 非线性结构
##### Set
###### HashSet(哈希表)
###### LinkedHashSet(哈希链表)
###### TreeSet(红黑树)
##### Map
###### HashMap(哈希表)
###### LinkedHashMap(有序哈希)
###### TreeMap(红黑树)

### 算法
#### 函数式编程（Lambda）
#### 迭代器（Iterator）
#### 流式编程(Stream API)
#### 工具类与API
##### Arrays
##### sort
##### binarySearch

#### 排序算法
##### 快速排序
##### 归并排序
##### 堆排序
#### 查找算法

#### 递归算法
#### 动态规划
#### 贪心算法
##### dijkstra算法
#### 回溯算法
---
### IO
### 多线程
### 网络编程
### 反射
### 动态代理
---
# JavaScript
## 变量声明
---
## 数据类型
### 基础类型
### 引用类型
---
## 运算符
---
## 函数
#### 函数声明
#### 函数表达式
#### 箭头函数
#### 作用域与闭包
---
## OOP
### 对象创建
### 原型与继承
### 内置对象
#### Object
#### Number
#### String
#### Boolean
#### Symbol
#### Array
#### Map
#### Set
#### Math
#### Date
---
## DOM操作
### 节点操作
### 事件系统
### BOM
#### 定时器
#### location&history
### localStorage&sessionStorage
### cooke
### 网络请求
#### XMLHttpRequset
#### Fetch API